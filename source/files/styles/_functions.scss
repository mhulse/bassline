//======================================================================
// Functions:
//======================================================================

// Remove units from `$value`.
//
// Usage:
//
// `.foo { line-height: strip(1.5em); }`
//
// Output:
//
// `.foo { line-height: 1.5; }`
//
// @see https://github.com/mhulse/rex/issues/77
// @see http://stackoverflow.com/a/12335841/922323
//
// @param { integer } $value Any value with optional unit.
// @return { integer } $value minus its unit.

@function strip($value) {
	
	@return ($value / ($value * 0 + 1));
	
}

//----------------------------------------------------------------------

// Convert `$value` to relative number.
//
// Usage:
//
// ```
// .foo {
//     font-size: #{relative(25px)}rem;
//     margin: #{relative(10)}em 0;
// }
// ```
//
// Output:
//
// ```
// .foo {
//     font-size: 1.5625rem;
//     margin: 0.625rem 0;
// }
// ```
//
// @param { integer } $value Can be a value with or without a unit.
// @param { integer } [ $context = $base_font-size ] Context of relative unit calculation.
// @return { integer } Relative result based on input params.

@function relative($value, $context: $base_font-size) {
	
	$value: strip($value);
	$context: strip($context);
	
	@return ($value / $context);
	
}

//----------------------------------------------------------------------

// Calculate baseline from `$value`, which is assumed to be the baseline's
// element's `font-size`.
//
// Usage:
//
// ```
// .foo {
//     line-height: baseline(25, .625);
//     padding: #{baseline(25, .375) / 2)}em 0;
// }
// ```
//
// Output:
//
// ```
// .foo {
//     line-height: 1.2;
//     padding: 0.36em 0;
// }
// ```
//
// @param { integer } $value An integer, assumed to be in pixels, where unit is optional.
// @param { integer } [ $offset = 1 ] Multiply the return value by this number.
// @param { integer } [ $context = $base_line-height ] Base `line-height` of document.
// @return { integer } A number relative to baseline.

@function baseline($value, $offset: 1, $context: $base_line-height) {
	
	$value: strip($value);
	$offset: strip($offset);
	$context: strip($context);
	
	@return ((($context * ceil($value / $context)) / $value) * $offset);
	
}

// Convert input list string of values with units.
//
// Rules:
//
// 1) First argument is required:
//    * It's value must be one of `baseline` or `relative`.
//    * An items's optional argument will override this setting.
// 2) If an item's unit exists, then retain item and unit on ouput.
// 3) If value is zero, do not add a unit.
// 4) If unit doesn't exist, then convert unit a relative value.
// 5) If an item's optional arguments exist:
//    * If argument is a number, then multiply value by number.
//    * If argument is a string, then use that as callback function.
//
// Usage:
//
// ```
// .foo {
//     prop: expand(
//         relative,       // Expected:
//         50% .2,         // 10%
//         25%,            // 25%
//         10px,           // 10px
//         20 .5 baseline, // .6rem
//         8 baseline,     // 3rem
//         0,              // 0
//         22em .875,      // 19.25em
//         50px,           // 50px
//         222             // 13.875rem
//     );
// }
// ```
//
// Output:
//
// ```
// .foo {
//     prop: 10% 25% 10px 0.6rem 3rem 0 19.25em 50px 13.875rem;
// }
// ```
//
// @see http://css-tricks.com/snippets/css/less-mixin-for-rem-font-sizing/
// @see http://stackoverflow.com/a/6575710/922323
// @see http://hugogiraudel.com/2013/07/15/understanding-sass-lists/
// @see http://thesassway.com/advanced/pure-sass-functions
// @see http://stackoverflow.com/a/14884562/922323
//
// @param { string } $function Name of function used to process unitless values.
// @param { list } $list... List of values with optional units offsets and/or callbacks.
// @return { string } Processed list as string of values with units.

@function expand($function, $list...) {
	
	// Neutralize return value:
	$return: null;
	
	// Requre first argument as string:
	@if type_of($function) != string {
		
		@warn "First argument must be string; one of `baseline` or `relative`.";
		
	} @else {
		
		// Prepare return value for string concatenation:
		$return: "";
		
		// Total items in list:
		$count: length($list);
		
		// Loop over list:
		@for $i from 1 through $count {
			
			// Current list key:
			$key: nth($list, $i);
			
			// Number of list items in key:
			$size: length($key);
			
			// Initialize:
			$arg1: false;
			
			// First optional argument?
			@if $size > 1 {
				
				// Get first optional argument:
				$arg1: nth($key, 2); // I wish I could use nth() without getting an error (or have ability to specify default return value).
				
			}
			
			// Initialize:
			$arg2: false;
			
			// Second optional argument?
			@if $size > 2 {
				
				// Get second optional argument:
				$arg2: nth($key, 3); // IBID.
				
			}
			
			// First value in key:
			$value: nth($key, 1);
			
			// Get the value's unit:
			$unit: unquote(unit($value));
			
			// Strip any units from value:
			$value: strip($value);
			
			// If no unit specified and value is not zero:
			@if $unit == "" and $value > 0 { // SASS 3.3, use `str-length($unit)`.
				
				// Default to `rem`:
				$unit: rem;
				
				// Local `$function` argument?
				@if type_of($arg1) == string or type_of($arg2) == string {
					
					// Convert unit to a relative value:
					$value: if($arg1 == baseline or $arg2 == baseline, baseline($value), relative($value)); // @TODO: Use string for `$function` instead of hard coding.
					
				} @else {
					
					// No local `$function` argument, so use global `$function`:
					$value: if($function == baseline, baseline($value), relative($value)); // @TODO: Re-factor this logic; I'm a little frustrated with SASS limitations and also my inexperience with the language.
					
				}
				
			}
			
			// Offset?
			@if type_of($arg1) == number or type_of($arg2) == number {
				
				// @TODO: SASS 3.3 shorthand `if()` should be used instead.
				@if type_of($arg1) == number {
					
					// Multiply value by first argment:
					$value: $value * $arg1;
					
				} @else {
					
					// Multiply value by second argment:
					$value: $value * $arg2;
					
				}
				
			}
			
			// Combine unit and value:
			$return: #{$return + $value}$unit;
			
			// Before reaching the end ...
			@if $i < $count {
				
				// ... put a space between return values:
				$return: #{$return + " "};
				
			}
			
		}
		
	}
	
	// Return string of new values and units:
	@return $return;
	
}
